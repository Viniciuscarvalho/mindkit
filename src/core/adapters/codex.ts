import { join } from 'node:path';
import { homedir } from 'node:os';
import { BaseAdapter } from './base.js';
import type {
  ToolDetection,
  TemplateConfig,
  InstallResult,
  ComponentType,
  PathTransform,
} from '../../types/index.js';

/**
 * Adapter for OpenAI Codex CLI
 *
 * Structure:
 * - ~/.codex/config.toml - Global configuration
 * - ~/.codex/AGENTS.md - Global agent instructions
 * - AGENTS.md - Project-level instructions
 */
export class CodexAdapter extends BaseAdapter {
  readonly tool = 'codex' as const;
  readonly name = 'Codex';
  readonly description = 'OpenAI Codex CLI';

  private readonly globalDir = join(homedir(), '.codex');

  getGlobalConfigDir(): string {
    return this.globalDir;
  }

  getProjectConfigPath(projectRoot: string): string {
    return join(projectRoot, 'AGENTS.md');
  }

  async detect(): Promise<ToolDetection> {
    const configExists = await this.pathExists(this.globalDir);
    const configToml = join(this.globalDir, 'config.toml');
    const tomlExists = await this.pathExists(configToml);

    // Check if 'codex' command exists in PATH
    const commandExists = this.commandExists('codex');

    // Tool is installed if command exists OR config directory/file exists
    const installed = commandExists || configExists || tomlExists;

    return {
      tool: this.tool,
      installed,
      configPath: configExists ? this.globalDir : null,
    };
  }

  protected getDefaultTransforms(projectRoot?: string): PathTransform[] {
    return [
      { type: 'variable', from: 'DOCS', to: './docs' },
      { type: 'variable', from: 'PROJECT', to: projectRoot || '.' },
      { type: 'variable', from: 'HOME', to: homedir() },
      { type: 'variable', from: 'CONFIG', to: this.globalDir },
    ];
  }

  /**
   * Format content as a section for AGENTS.md
   */
  private formatAsSection(content: string, sectionHeader: string): string {
    return `\n## ${sectionHeader}\n\n${content}\n`;
  }

  /**
   * Merge content into existing AGENTS.md
   */
  private async mergeIntoAgents(
    targetPath: string,
    content: string,
    sectionHeader: string
  ): Promise<void> {
    const existingContent = await this.readConfig(targetPath);
    const section = this.formatAsSection(content, sectionHeader);

    if (!existingContent) {
      // Create new file with header
      const newContent = `# AGENTS.md\n\nGenerated by mindkit\n${section}`;
      await this.writeConfig(targetPath, newContent);
      return;
    }

    // Check if section already exists
    const sectionRegex = new RegExp(`## ${sectionHeader}[\\s\\S]*?(?=\\n## |$)`, 'g');
    if (sectionRegex.test(existingContent)) {
      // Replace existing section
      const updatedContent = existingContent.replace(sectionRegex, section.trim());
      await this.writeConfig(targetPath, updatedContent);
    } else {
      // Append new section
      await this.writeConfig(targetPath, existingContent + section);
    }
  }

  async install(
    template: TemplateConfig,
    content: string,
    projectRoot?: string
  ): Promise<InstallResult> {
    const target = template.targets.codex;
    if (!target) {
      return {
        template,
        tool: this.tool,
        success: false,
        targetPath: '',
        error: 'No Codex target configured for this template',
      };
    }

    try {
      // Apply transforms
      const transforms = [
        ...this.getDefaultTransforms(projectRoot),
        ...(template.transforms || []),
      ];
      const transformedContent = this.transformContent(content, transforms);

      // Expand target path
      let targetPath = target.path;
      if (targetPath.startsWith('~')) {
        targetPath = targetPath.replace('~', homedir());
      } else if (projectRoot && !targetPath.startsWith('/')) {
        targetPath = join(projectRoot, targetPath);
      }

      // Handle merge mode (for AGENTS.md)
      if (target.merge) {
        await this.mergeIntoAgents(
          targetPath,
          transformedContent,
          target.sectionHeader || template.name
        );
      } else {
        await this.writeConfig(targetPath, transformedContent);
      }

      return {
        template,
        tool: this.tool,
        success: true,
        targetPath,
      };
    } catch (error) {
      return {
        template,
        tool: this.tool,
        success: false,
        targetPath: target.path,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  async listInstalled(_type: ComponentType): Promise<string[]> {
    // Codex uses AGENTS.md for everything
    // We'll parse sections from the global AGENTS.md
    const agentsPath = join(this.globalDir, 'AGENTS.md');
    const content = await this.readConfig(agentsPath);

    if (!content) {
      return [];
    }

    // Extract section headers
    const sectionRegex = /^## (.+)$/gm;
    const sections: string[] = [];
    let match;

    while ((match = sectionRegex.exec(content)) !== null) {
      sections.push(match[1]);
    }

    return sections;
  }
}
